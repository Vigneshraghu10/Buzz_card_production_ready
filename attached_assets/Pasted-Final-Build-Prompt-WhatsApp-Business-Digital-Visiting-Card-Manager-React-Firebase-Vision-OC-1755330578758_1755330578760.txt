Final Build Prompt — “WhatsApp Business Digital Visiting Card Manager” (React + Firebase + Vision OCR)
Objective

Build a production-ready React application for managing digital visiting cards for WhatsApp Business. The app supports user authentication, contact & group management, OCR from card images using Google Cloud Vision, a live Digital Card builder with vCard/QR export, and a public share page.
All app data (auth, CRUD, uploads) must be stored in Firebase (Authentication, Firestore, Storage). No external DB.

Tech Stack

React + Vite

Tailwind CSS

React Router v6+

Context API (Auth state)

Firebase Web SDK (Auth, Firestore, Storage)

Google Cloud Vision API (TEXT_DETECTION)

QR code + vCard generation (client-side)

TypeScript preferred (OK to use JS if needed)

Environment & Config

Use .env with Vite-style vars:

VITE_FIREBASE_API_KEY=...
VITE_FIREBASE_AUTH_DOMAIN=...
VITE_FIREBASE_PROJECT_ID=...
VITE_FIREBASE_STORAGE_BUCKET=...
VITE_FIREBASE_MESSAGING_SENDER_ID=...
VITE_FIREBASE_APP_ID=...

VITE_GCLOUD_VISION_API_KEY=...
VITE_APP_PUBLIC_BASE_URL=https://your-domain.com


Do not store secrets in Firestore. Vision key is loaded via env at build/runtime.

Firebase Init (create src/lib/firebase.ts)
import { initializeApp } from "firebase/app";
import { getAuth } from "firebase/auth";
import { getFirestore } from "firebase/firestore";
import { getStorage } from "firebase/storage";

const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
};

export const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
export const db = getFirestore(app);
export const storage = getStorage(app);

Routing & Guards

Public routes:

/login

/register

/share/:publicId (public profile card view, non-sensitive fields + “Save Contact (.vcf)”)

Private routes (require Auth):

/ (Dashboard)

/contacts

/groups

/templates

/bulk-uploads

/scanned-cards

/digital-card

/settings

/nfc-card (Coming Soon)

/logout

Create a PrivateRoute wrapper using Auth Context to guard routes. Redirect unauthenticated users to /login.

Layout

Stable Left Sidebar on all private pages with links:
Dashboard / Contacts / Groups / Templates / Bulk Uploads / Scanned Cards / Digital Card / Settings / NFC Card (Coming Soon) / Logout

Top Navbar shows logged-in user’s displayName/email and avatar (if any).

Authentication

Firebase Auth: Email/Password Login + Register

Show helpful errors and loading states.

After login/register, redirect to Dashboard.

Persist auth state via Firebase (no custom localStorage for auth).

Firestore — Data Model (ALL data here)

All docs include ownerId = auth.uid.
Collections:

users (uid, email, displayName, createdAt)

contacts (firstName, lastName, phone, email, company, services, groupIds: string[], createdAt, ownerId, address?)

groups (name, createdAt, ownerId)

templates (name, content, createdAt, ownerId)

scannedCards (imageUrl, extractedData, createdAt, ownerId)

digitalCards (ownerId, publicId, avatarUrl, firstName, lastName, title, company, email, phone, website, address, services, testimonials, updatedAt, isPublic: boolean)

settings (doc id = ownerId; displayName, businessName, defaultWhatsAppNumber, language, timezone, updatedAt)

All application state that represents user data must persist to Firestore. Ephemeral UI state (modals, toggles) can remain local.

Firebase Security Rules
Firestore Rules (firestore.rules)
// Firestore Rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(resourceOwnerId) {
      return isSignedIn() && request.auth.uid == resourceOwnerId;
    }

    // Users can read/write their own user doc
    match /users/{uid} {
      allow read, create: if isSignedIn() && request.auth.uid == uid;
      allow update, delete: if isOwner(resource.data.ownerId) || (isSignedIn() && request.auth.uid == uid);
    }

    // Collections that store app data with ownerId
    match /{collectionName}/{docId} where
      collectionName in ['contacts','groups','templates','scannedCards','digitalCards','settings'] {

      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;

      allow read, update, delete: if isSignedIn() && isOwner(resource.data.ownerId);
    }

    // Public share page: allow read of specific public fields by publicId
    match /digitalCards/{docId} {
      allow read: if isSignedIn() && isOwner(resource.data.ownerId)
                  || (request.resource == null && resource.data.isPublic == true);
      allow create, update, delete: if isSignedIn() && isOwner(resource.data.ownerId);
    }
  }
}

Storage Rules (storage.rules)
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    function isSignedIn() { return request.auth != null; }

    // Store under /users/{uid}/...
    match /users/{uid}/{allPaths=**} {
      allow read: if isSignedIn() && request.auth.uid == uid;
      allow write: if isSignedIn() && request.auth.uid == uid;
    }

    // Block all else
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}

Features & Pages
1) Dashboard

Show Firestore counts: Contacts, Groups, Templates, Scanned Cards.

Quick Actions: Add Contact → Contacts; Create Template → Templates; Bulk Upload → Bulk Uploads; Scan Card → Scanned Cards.

Recent Activities: latest scannedCards entries (sort by createdAt desc).

2) Contacts

Grid (default) / Table view toggle.

Search bar filters by name/email/phone/company (client-side + optionally Firestore query).

Add Contact modal: First Name, Last Name, Phone, Email, Company, Services (multiline), Address (optional), Assign to Group (dropdown).

Show group labels on each contact card.

Prevent duplicates before save: check existing contacts where phone OR email match (case-insensitive).

3) Groups

List groups.

Create Group modal (Group Name).

Add Contact to group (multi-select to push groupIds).

Remove group (delete doc + remove groupId from any contacts referencing it).

4) Templates

List templates.

Create Template modal: name, content (textarea).

Use templates for WhatsApp placeholders (pure UI placeholder — no actual API call).

5) Bulk Uploads

Upload up to 10 images → Firebase Storage at /users/{uid}/bulk/{timestamp}-{filename}.

For each file:

Get public download URL.

Call Vision API (TEXT_DETECTION).

Parse fullTextAnnotation.text into { name, company, phone, email, services, address, qr }.

Show results in a grid with Remove option.

Save All → create contacts docs (de-dupe by phone/email).

After save, prompt to assign to existing group or create new group and assign.

6) Scanned Cards

Single image upload.

Upload to Storage /users/{uid}/scans/{timestamp}-{filename}.

Call Vision API, show parsed fields.

Actions:

Save → to contacts (with de-dupe).

Send Template → pick from templates (placeholder “sent” toast).

Send Profile → uses settings.defaultWhatsAppNumber (placeholder).

7) Digital Card (NEW)

Form:

Profile Picture (upload to Storage /users/{uid}/avatar.jpg → avatarUrl)

First Name, Last Name, Title, Company, Email, Phone, Website, Address

Services (multiline), Clients/Testimonials (multiline)

Live Preview Panel updates as user types.

Generate QR from a vCard text payload (v3.0 or v4.0).

Scanning should open native Add-to-Contacts with details prefilled.

Buttons:

Save Profile → upsert into digitalCards (by ownerId), include publicId (stable slug or random), isPublic flag.

Download .vcf

Download QR.png

Copy share link → ${VITE_APP_PUBLIC_BASE_URL}/share/${publicId}

8) Public Share Route /share/:publicId (no auth)

Read only public fields from digitalCards found by publicId.

Render a lightweight profile card + “Save Contact (.vcf)” button (generates vCard client-side).

No sensitive fields beyond what’s on the card.

9) Settings

Profile & App preferences:

Display Name (default from auth), Business Name

Default WhatsApp number (used by “Send Profile” placeholder)

WhatsApp Business API credential placeholders (UI validation only, never stored as secrets)

Timezone, Language

Save to settings/{ownerId}.

Button: “Send Test Template” (placeholder).

10) NFC Card

Big “Coming Soon” placeholder (icon + CTA).

Vision API (OCR)

Endpoint:

POST https://vision.googleapis.com/v1/images:annotate?key=VITE_GCLOUD_VISION_API_KEY


Payload:

{
  "requests": [{
    "image": { "source": { "imageUri": "<PUBLIC_IMAGE_URL>" } },
    "features": [{ "type": "TEXT_DETECTION" }]
  }]
}


Client util (src/utils/ocr.ts):

export async function callVisionAPI(imageUrl: string): Promise<string> {
  const key = import.meta.env.VITE_GCLOUD_VISION_API_KEY;
  const res = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${key}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      requests: [{
        image: { source: { imageUri: imageUrl } },
        features: [{ type: "TEXT_DETECTION" }]
      }]
    })
  });
  const json = await res.json();
  return json?.responses?.[0]?.fullTextAnnotation?.text ?? "";
}

Parsing Utility (OCR → Contact)

src/utils/parse.ts:

export type ParsedContact = {
  name?: string;
  company?: string;
  phone?: string;
  email?: string;
  services?: string;
  address?: string;
  qr?: string;
};

export function parseOcrToContact(text: string): ParsedContact {
  const emailMatch = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i);
  const phoneMatch = text.replace(/[\s\-().]/g,'').match(/(\+?\d{10,15})/);
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

  // heuristics: first non-email/phone line w/ capitalized words ~ name
  const likelyName = lines.find(l => !l.toLowerCase().includes("phone") && !l.includes("@") && l.split(' ').every(w => /^[A-Za-z.&-]+$/.test(w)));
  const company = lines.find(l => /pvt|ltd|llp|inc|co\.|company|studio|technolog|solutions|industr/i.test(l)) ?? lines[1];

  // very lightweight
  const servicesIdx = lines.findIndex(l => /services|what we do|offerings/i.test(l));
  const services = servicesIdx >= 0 ? lines.slice(servicesIdx).join(", ") : undefined;

  // address: last 2–5 lines w/ commas & numbers
  const addrLines = lines.slice(-5).filter(l => /[,0-9]/.test(l));
  const address = addrLines.join(", ");

  return {
    name: likelyName,
    company,
    phone: phoneMatch?.[1],
    email: emailMatch?.[0],
    services,
    address
  };
}

vCard & QR Utilities

src/utils/vcard.ts:

export function buildVCard(profile: {
  firstName?: string; lastName?: string; title?: string; company?: string;
  email?: string; phone?: string; website?: string; address?: string;
}) {
  const fn = [profile.firstName, profile.lastName].filter(Boolean).join(" ");
  const n = `${profile.lastName || ""};${profile.firstName || ""};;;`;
  const org = profile.company || "";
  const title = profile.title || "";
  const tel = profile.phone || "";
  const email = profile.email || "";
  const url = profile.website || "";
  const adr = profile.address ? `;;${profile.address.replace(/\n/g,";")}` : ";;;;;";
  return [
    "BEGIN:VCARD",
    "VERSION:3.0",
    `FN:${fn}`,
    `N:${n}`,
    `ORG:${org}`,
    `TITLE:${title}`,
    tel ? `TEL;TYPE=CELL:${tel}` : null,
    email ? `EMAIL:${email}` : null,
    url ? `URL:${url}` : null,
    `ADR:${adr}`,
    "END:VCARD"
  ].filter(Boolean).join("\n");
}


src/utils/qr.ts (use any QR lib or canvas):

export async function generateQrFromText(text: string): Promise<string> {
  // Use a QR library (e.g., qrcode) to return a dataURL for PNG
  const { toDataURL } = await import('qrcode');
  return await toDataURL(text);
}

Storage Upload Helper

src/utils/upload.ts:

import { getDownloadURL, ref, uploadBytes } from "firebase/storage";
import { storage } from "../lib/firebase";

export async function uploadToStorage(file: File, path: string): Promise<string> {
  const r = ref(storage, path);
  await uploadBytes(r, file);
  return await getDownloadURL(r);
}

De-dupe Helper (Contacts)
import { collection, getDocs, query, where, limit } from "firebase/firestore";
import { db } from "../lib/firebase";

export async function isDuplicateContact(ownerId: string, email?: string, phone?: string) {
  const col = collection(db, "contacts");
  const filters = [];
  if (email) filters.push(where("email", "==", email.toLowerCase()));
  if (phone) filters.push(where("phone", "==", phone));
  if (!filters.length) return false;
  const q = query(col, where("ownerId","==",ownerId), ...filters, limit(1));
  const snap = await getDocs(q);
  return !snap.empty;
}

Auth Context & PrivateRoute

AuthContext provides user, loading, login, register, logout.

PrivateRoute checks user; redirects to /login if absent.

UI/UX Requirements

Tailwind for clean cards, accessible modals, mobile-friendly.

Loading states for every async action (Firestor/Storage/Vision).

Error toasts on failures; success toasts on saves.

Sidebar remains fixed; main content scrolls.

“NFC Card” page: centered “Coming Soon” with icon.

Folder Structure (suggested)
src/
  components/ (shared UI)
  pages/
    Auth/
      Login.tsx
      Register.tsx
    Dashboard/
    Contacts/
    Groups/
    Templates/
    BulkUploads/
    ScannedCards/
    DigitalCard/
    Settings/
    NFCCard/
    PublicShare/
  contexts/
    AuthContext.tsx
  lib/
    firebase.ts
  utils/
    upload.ts
    ocr.ts
    parse.ts
    vcard.ts
    qr.ts
    whatsapp.ts (placeholder functions)
  routes/
    PrivateRoute.tsx
  App.tsx
  main.tsx
  index.css

Acceptance Criteria

ALL persistent data is stored in Firebase:

Auth: Firebase Authentication

Documents: Firebase Firestore (with ownerId)

Files: Firebase Storage (/users/{uid}/...)

Auth flows (login/register) work; private routes protected.

Dashboard shows counts + recent scanned cards.

Contacts CRUD with grid/table view, search, add modal, group labels, de-dupe on save.

Groups CRUD; removing a group cleans references from contacts.

Templates CRUD; selectable in Scanned Cards “Send Template” placeholder.

Bulk Uploads: up to 10 images → Storage → Vision OCR → parsed results grid → Save All (with de-dupe) → optional group assignment.

Scanned Cards: single upload → Storage → Vision OCR → parsed preview → Save / Send Template (placeholder) / Send Profile (placeholder).

Digital Card: live preview, avatar upload, Save Profile to digitalCards with publicId, vCard build, QR generate, download .vcf, download QR.png, copy share link.

Public share page /share/:publicId shows public fields + “Save Contact (.vcf)”.

Settings saved to settings/{ownerId}; “Send Test Template” is a placeholder action.

Firestore & Storage Security Rules enforce owner isolation; public read only for digitalCards with isPublic.

Clean Tailwind UI, accessible modals, and robust loading/error handling.

Notes

Use server timestamps (serverTimestamp()) for createdAt/updatedAt.

Normalize emails to lowercase for de-dupe.

For publicId, generate a slug from name or a short random ID; ensure uniqueness per user.

Optionally add Firestore composite indexes for queries (e.g., ownerId + createdAt).

Do not include real WhatsApp Business API calls — placeholders only.

Deliverables

Complete React + Vite codebase with all routes, components, context, utils, and Tailwind styling.

firestore.rules and storage.rules.

README.md with setup: Firebase project, env vars, how to deploy (e.g., Firebase Hosting/Vercel/Netlify).

Demo seeds optional.